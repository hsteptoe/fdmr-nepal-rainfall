# Modelling Nepal-Rainfall

## Essential Libaries

```{r}
library(INLA)
library(magrittr)
library(qs)
library(inlabru)
library(sp)
library(dplyr)
library(tibble)
```

## Read in the dataset

```{r}
nepal_data <- qread('nepal-data-big.qs')
```

## Subset the data
```{r}
# subset daily data for the period we are interested in
daily_subset <- nepal_data %>% 
  filter(date > as.Date("2019-06-01"), 
         date < as.Date("2019-09-30"),
         lon > 85.5,
         lon < 86.5,
         lat > 27.5,
         lat < 28.0)
```
## Add the observed data
```{r}
# Read in observed data and bind to modelled data
obs_long_daily<- read.csv('observed_data.csv')
obs_long_daily <- obs_long_daily %>% mutate(date = as.Date(date)) # make sure in date format
daily_reformat <- data.frame(date = daily_subset$date, 
                             name = daily_subset$model,
                             precip = daily_subset$prcp,
                             lon = daily_subset$lon,
                             lat = daily_subset$lat)

nepal_subset <- bind_rows(obs_long_daily,daily_reformat) %>% 
  mutate(doy = yday(date)) #doy works for a single year but may need to rethink for more
```

# Dataset Sanity-checks

```{r}
head(nepal_subset)
```

```{r}
names(nepal_subset)
```

#### Mesh Builder ####

```{r loadshape, error=TRUE}
fdmr::mesh_builder(spatial_data = nepal_subset, x_coord = "lon", y_coord = "lat")
```
Now we have the spatial data loaded we can think about some initial parameters for the mesh we're going to create. We'll calculate the initial range and max edge values from our data and
pass them into the `mesh_builder` function. These values will then be used as values for the initial mesh that's created but can be changed within the app.

```{r eval=FALSE}
initial_range <- diff(range(nepal_subset[, "lon"])) / 5
max_edge <- initial_range / 8

max_edge_fin <- c(1, 2) * max_edge
offset <- c(initial_range / 4, initial_range)
cutoff <- max_edge / 7
```
> **_NOTE:_** By default we let `fmesher` select the defaults for these values itself. If you encounter long mesh build times try using the `meshbuilder` defaults of NULL values for `max_edge` etc. 

Now we're ready to start the app.

```{r eval=FALSE}
fdmr::mesh_builder(spatial_data = nepal_subset, x_coord = "lon", y_coord = "lat", max_edge = max_edge_fin, offset = offset, cutoff = cutoff)
```

## Exporting mesh

```{r}
scalar <- 10 # to simplify the mesh, smaller val <=> higher res.
location_data <- nepal_subset[, c('lon', 'lat')]
names(location_data) <- c('LONG', 'LAT')
mesh <- fmesher::fm_mesh_2d_inla(loc = location_data,
	max.edge = c(0.2109375,0.421875)+scalar,
	cutoff = 0.0301339285714286*scalar,
	offset = c(0.421875,0.421875))
fdmr::plot_mesh(mesh)
```

#### Modelling (COVID tutorial) ####
<!-- Now we make a map of the study region -->

<!-- ```{r rmap, error=TRUE,fig.cap="A map of the study region.", fig.width=8, fig.height=4, fig.align='center'} -->
<!-- nepal_data@data$mapp <- 0 -->
<!-- domain <- nepal_data@data$mapp -->

<!-- fdmr::plot_map(raster_data = nepal_data, domain = domain, add_scale_bar = TRUE, polygon_fill_opacity = 0.5, palette = "YlOrRd") -->
<!-- ``` -->
## Quick look at the data 
Double counting of precip model may be happening

```{r}
nepal_subset %>%
  ggplot( aes(x=date, y=precip, group=name, color=name)) +
    geom_line() +
    #scale_color_viridis(discrete = TRUE) +
    labs(title = "Precip Data") +
    #theme_ipsum() +
    ylab("Date")+
    facet_wrap(~name)
```

# Build the SPDE model on the mesh and set priors for the spatial parameters
We use the INLA::inla.spde2.pcmatern() function to build the SPDE model and specify Penalised Complexity (PC) priors for the parameters of the Matérn field. PC priors for the parameters range and marginal standard deviation of the Matérn field are specified by setting the values $m_r$, $p_r$,  $m_\sigma$ and $p_\sigma$ in the relations that P(spatial range<$m_r$)= $p_r$, and  P($\sigma>m_\sigma$)= $p_\sigma$. The spatial range of the process is the distance at which the correlation between two values is close to 0.1. In this study we use a prior of P(spatial range<1.480)= 0.5 for the spatial range parameter based on an exploratory variogram analysis

```{r spde, error=TRUE}
prior_range <- initial_range
spde <- INLA::inla.spde2.pcmatern(
  mesh = mesh,
  prior.range = c(prior_range, 0.5),
  prior.sigma = c(1, 0.01)
)
```

# Define how the process evolves over time and set prior for the temporal parameter

<!-- The previous step has specified that in each of the time periods the spatial locations are linked by the SPDE model. Now we assume that across time the process evolves according to a first order autoregressive (AR(1)) process. We specify a PC prior for the temporal autocorrelation parameter $\alpha \in [-1,1]$. The prior is given by `rhoprior`, which is a PC prior with P($\alpha>0$)=0.9.  -->

# Define the model formula

We will use the function `bru()` of package `inlabru` to fit the model. `bru` expects the coordinates of the data, thus we transform `nepal_data` data set to a SpatialPointsDataFrame using the function `coordinates()` of the `sp` package.

```{r, error=TRUE}
sp::coordinates(nepal_subset) <- c("lon", "lat")
proj4string(nepal_subset) <- CRS("+init=epsg:4326")
```


<!--```{r convert_to_utm} -->
<!-- nepal_utm <- fdmr::latlong_to_utm( -->
<!--   lat = nepal_data$lat, -->
<!--   lon = nepal_data$long -->
<!-- ) -->
<!-- ``` -->


```{r}
matern <- inla.spde2.pcmatern(
  mesh = mesh,
  prior.range = c(500, 0.5),
  prior.sigma = c(1, 0.5)
)

formula <- precip ~ 0 + Intercept(1) + f(main = coordinates,
    model = matern, group = doy)
```

# Fit the model

Finally, we fit the spatio-temporal model using spde approach and AR(1) process by calling the function `bru()` of the package `inlabru`. 

> **_NOTE:_**  Since the data size is quite large the memory requirements of this function call are high. We recommend running on a suitable high memory system. In our case it takes about 13 hours to complete.   

<!-- ```{r fitmodel, error=TRUE, eval=FALSE} -->
<!-- fdmr::model_builder(spatial_data = nepal_data, measurement_data = nepal_data, mesh = mesh, time_variable = "cyear") -->
<!-- ``` -->

```{r}
fit <- bru(formula, family="gaussian", data=nepal_subset, options=list(bru_verbose=4,verbose=TRUE))
```

